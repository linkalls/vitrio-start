import { readdirSync, statSync, writeFileSync } from 'node:fs'
import { join, relative, extname } from 'node:path'

// Convention:
// - Any file under src/** ending with *.client.tsx is treated as a client island.
// - Recommended: default export the component.
// - Optional: export const ISLAND_NAME = 'Name' to override naming.
//
// This script generates src/client/islands.gen.ts which exports `islands` registry.

const ROOT = process.cwd()
const ISLANDS_DIR = join(ROOT, 'src')
const OUT_CLIENT = join(ROOT, 'src', 'client', 'islands.gen.ts')
const OUT_SERVER = join(ROOT, 'src', 'server', 'islands.gen.tsx')

type Entry = { file: string; importPath: string; stem: string }

function walk(dir: string, out: Entry[]) {
  if (!statSync(dir).isDirectory()) return
  for (const name of readdirSync(dir)) {
    const full = join(dir, name)
    const st = statSync(full)
    if (st.isDirectory()) {
      // Skip client runtime & server folders to avoid self-import loops
      if (full.endsWith(join('src', 'client')) || full.endsWith(join('src', 'server'))) continue
      walk(full, out)
      continue
    }

    if (st.isFile() && name.endsWith('.client.tsx')) {
      // Create import path relative to src/client (because islands.gen.ts lives there)
      const rel = relative(join(ROOT, 'src', 'client'), full)
      const importPath = './' + rel.replace(/\\/g, '/').replace(/\.tsx$/, '')
      const stem = name.replace(/\.client\.tsx$/, '')
      out.push({ file: full, importPath, stem })
    }
  }
}

const entries: Entry[] = []
try {
  walk(ISLANDS_DIR, entries)
} catch {
  // no islands dir
}

const imports: string[] = []
const regs: string[] = []

const serverHelpers: string[] = []

entries.forEach((e, i) => {
  const alias = `m${i}`
  const stem = JSON.stringify(e.stem)
  imports.push(`import * as ${alias} from ${JSON.stringify(e.importPath)}`)

  // Naming rules:
  // 1) export const ISLAND_NAME = 'Name'
  // 2) fallback to file stem: Counter.client.tsx -> "Counter"
  const nameExpr = `${alias}.ISLAND_NAME ?? ${stem}`

  // Component selection rules:
  // 1) default export
  // 2) named export matching ISLAND_NAME
  // 3) named export matching stem
  // 4) first function export
  const compExpr = `(${alias}.default ?? ${alias}[${alias}.ISLAND_NAME ?? ${stem}] ?? ${alias}[${stem}] ?? Object.values(${alias}).find((v) => typeof v === 'function'))`

  regs.push(`  [${nameExpr}]: ${compExpr}`)

  // Server helper: remove manual name wiring in app code.
  // Emits: export function CounterIsland(props, children?) { return <IslandMarker name="Counter" props={props}>{children}</IslandMarker> }
  serverHelpers.push(
    `export function ${e.stem}Island(p: { props?: any; children?: any }) {\n` +
      `  return <IslandMarker name={${nameExpr}} props={p.props ?? {}}>{p.children}</IslandMarker>\n` +
      `}`,
  )
})

const contentClient = `// AUTO-GENERATED by scripts/gen-islands.ts
// Do not edit manually.

import type { IslandRegistry } from './islands'
${imports.join('\n')}

export const islands: IslandRegistry = {
${regs.join(',\n')}
}
`

const contentServer = `// AUTO-GENERATED by scripts/gen-islands.ts
// Do not edit manually.

import { IslandMarker } from './islands'

${serverHelpers.join('\n\n')}
`

writeFileSync(OUT_CLIENT, contentClient)
writeFileSync(OUT_SERVER, contentServer)
console.log('[gen-islands] wrote', OUT_CLIENT)
console.log('[gen-islands] wrote', OUT_SERVER)
