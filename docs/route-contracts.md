# Route Contracts & Cache Keys

This document explains how routes, loaders, actions, and caching work together in vitrio-start.

## Route Definition Contract

### Basic Structure

```tsx
export interface RouteDef<TLoaderData, TActionData> {
  path: string                        // Route pattern (e.g., "/users/:id")
  loader?: LoaderFunction             // Optional: fetch data for GET requests
  action?: ActionFunction             // Optional: handle POST requests
  component: ComponentFunction        // Required: render UI
}
```

### Loader Contract

A loader is a function that runs before rendering to fetch data.

**Signature:**
```tsx
type LoaderFunction<T> = (ctx: LoaderContext) => 
  Promise<LoaderResult<T>> | LoaderResult<T>

type LoaderContext = {
  params: Record<string, string>      // URL params (e.g., { id: "123" })
  search: URLSearchParams             // Query string
  location: {
    path: string                      // Current pathname
    query: string                     // Query string with "?"
    hash: string                      // Hash with "#"
  }
}

type LoaderResult<T> = T | RedirectResult | NotFoundResult
```

**When loaders run:**
1. **Server-side (SSR)**: On initial page load
2. **Client-side**: On route navigation (using client-side fetch)

**Loader execution flow (SSR):**
1. Framework finds all matching routes for the current path
2. Loaders run in order from parent to child (prefix → leaf)
3. URL params are merged parent → child
4. Loader results are cached in `loaderCache` map
5. Results are serialized to `__VITRIO_LOADER_CACHE__` in HTML
6. Client hydrates and uses cached results (no double execution)

**Examples:**

```tsx
// Simple loader
loader: async () => {
  return { posts: await fetchPosts() }
}

// Loader with params
loader: async (ctx) => {
  const post = await fetchPost(ctx.params.id)
  if (!post) return notFound()
  return { post }
}

// Loader with redirect
loader: async (ctx) => {
  const user = await getCurrentUser()
  if (!user) return redirect('/login')
  return { user }
}
```

---

## Action Contract

An action handles form submissions (POST requests).

**Signature:**
```tsx
type ActionFunction<T> = (ctx: ActionContext, formData: FormData) => 
  Promise<ActionResult<T>> | ActionResult<T>

type ActionContext = {
  params: Record<string, string>
  search: URLSearchParams
  location: { path: string; query: string; hash: string }
}

type ActionResult<T> = T | RedirectResult | NotFoundResult
```

**Action execution flow:**
1. User submits form → POST request
2. Framework validates CSRF token
3. Framework finds matching route and runs action
4. Action returns result:
   - `redirect(to)` → redirect to `to` (303 status, no flash)
   - `notFound()` → redirect back with flash `{ ok: false }`
   - `{ ...data }` → redirect back with flash `{ ok: true }`
5. Browser follows redirect → GET request

**Examples:**

```tsx
import { z } from 'zod'
import { parseFormData } from './server/form'

const schema = z.object({
  email: z.string().email(),
})

// Simple action
action: async (ctx, formData) => {
  const input = parseFormData(formData, schema)
  await subscribe(input.email)
  return { success: true }  // Flash: { ok: true }, redirect back
}

// Action with redirect
action: async (ctx, formData) => {
  await doSomething()
  return redirect('/dashboard')  // No flash, redirect to dashboard
}

// Action with error
action: async (ctx, formData) => {
  const valid = await validate(formData)
  if (!valid) return notFound()  // Flash: { ok: false }, redirect back
  return { ok: true }
}
```

---

## Loader Cache Contract

### Cache Key

The loader cache key is generated by `makeRouteCacheKey`:

```tsx
function makeRouteCacheKey(routeId: string, ctx: LoaderContext): string {
  // Simplified:
  return `${routeId}?${serializeParams(ctx.params)}&${ctx.search.toString()}`
}
```

**Key components:**
- `routeId`: Defaults to the route's `path` (e.g., `/users/:id`)
- `params`: URL parameters as query string
- `search`: Query string from URL

**Example keys:**
- Route: `/users/:id`, URL: `/users/123` → Key: `/users/:id?id=123`
- Route: `/posts/:id`, URL: `/posts/456?tab=comments` → Key: `/posts/:id?id=456&tab=comments`

### Cache Lifecycle

**SSR (Server-Side Rendering):**
1. Loader runs on server
2. Result is stored in `cacheMap` with cache key
3. `cacheMap` is serialized to `__VITRIO_LOADER_CACHE__` in HTML
4. Client reads `__VITRIO_LOADER_CACHE__` during hydration
5. Route components find their data in cache (no re-fetch)

**CSR (Client-Side Rendering):**
1. User navigates to a new route
2. Framework checks cache for existing data
3. If not cached, loader runs on client via fetch
4. Result is cached for future use

### Preventing Double Execution

The cache prevents loaders from running twice during SSR:

```
Without cache:
  Server runs loader → sends HTML
  Client hydrates → runs loader again (wasteful!)

With cache:
  Server runs loader → stores in cache → sends HTML + cache
  Client hydrates → reads cache (no duplicate request!)
```

---

## Special Return Values

### `redirect(to, status?)`

Redirect to another URL.

```tsx
import { redirect } from './server/response'

// From loader
loader: async (ctx) => {
  if (!authenticated) return redirect('/login')
  return { data: ... }
}

// From action
action: async (ctx, formData) => {
  await processForm(formData)
  return redirect('/success')  // Default status: 303
}
```

**Behavior:**
- **In loader**: Immediate redirect (no flash)
- **In action**: Immediate redirect (no flash)
- **Default status**: 303 (for actions), 302 (for loaders)

---

### `notFound(status?)`

Signal that a resource was not found.

```tsx
import { notFound } from './server/response'

// From loader
loader: async (ctx) => {
  const post = await fetchPost(ctx.params.id)
  if (!post) return notFound()
  return { post }
}

// From action (rare)
action: async (ctx, formData) => {
  const resource = await findResource(formData.get('id'))
  if (!resource) return notFound()
  return { ok: true }
}
```

**Behavior:**
- **In loader**: Sets 404 status, renders app with catch-all `*` route
- **In action**: Sets flash `{ ok: false }`, redirects back with 303

---

## Route Matching & Params

### Path Patterns

Routes support dynamic segments:

```tsx
"/users/:id"           // Matches: /users/123
"/posts/:id/edit"      // Matches: /posts/456/edit
"/blog/:year/:month"   // Matches: /blog/2024/12
```

### Param Merging

When multiple routes match, params are merged parent → child:

```tsx
routes = [
  { path: "/users/:userId", ... },          // Parent
  { path: "/users/:userId/posts/:postId", ... }  // Child
]

URL: /users/123/posts/456

// In child loader:
ctx.params = {
  userId: "123",   // from parent
  postId: "456"    // from child
}
```

---

## TypeScript Helpers

### `defineRoute` Helper

Use `defineRoute` for better type inference:

```tsx
import { defineRoute } from './routes'

const userRoute = defineRoute({
  path: '/users/:id',
  loader: async (ctx) => {
    return { user: await fetchUser(ctx.params.id) }
  },
  component: ({ data }) => {
    // data.user is typed!
    return <div>{data.user.name}</div>
  }
})
```

---

## Summary

| Concept | Key Point |
|---------|-----------|
| **Loader** | Runs before render to fetch data. Returns data, redirect, or notFound. |
| **Action** | Handles POST requests. Always triggers PRG (redirect). |
| **Cache Key** | `routeId + params + search`. Used to prevent double execution in SSR. |
| **Params** | Merged from parent routes to child routes. |
| **redirect()** | Immediately redirects (no flash). |
| **notFound()** | In loader: 404 status. In action: flash { ok: false }. |
| **PRG** | All actions redirect after processing (303 by default). |

---

## Best Practices

1. **Keep loaders pure**: Loaders should only fetch data, not mutate state.
2. **Use actions for mutations**: POST forms should use actions.
3. **Validate in actions**: Use Zod to validate form data.
4. **Return redirect explicitly**: Don't rely on framework magic.
5. **Use flash for feedback**: The framework automatically sets flash cookies.
6. **Type your routes**: Use `defineRoute` for better IntelliSense.

---

## Debugging Tips

### Check loader cache

In browser console:
```js
console.log(window.__VITRIO_LOADER_CACHE__)
```

### Check flash messages

In browser console:
```js
console.log(window.__VITRIO_FLASH__)
```

### Check route matching

In `src/server/framework.tsx`, enable logging:
```tsx
console.log('Matched routes:', matchedRoutes.map(r => r.path))
```
